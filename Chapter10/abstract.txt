使用内部类常见的方法是：外部类有一个方法，该方法返回一个指向内部类的引用。
如果想从Outer class 的非静态方法之外的任意位置创建某个内部类的对象。必须OuterClassName.InnerClassName

内部类天然的属性很重要：
当生成一个内部类的对象时，此对象与生成它的外部对象之间就有了联系，所以它能访问其外部类的所有成员，而不需要任何特殊条件。
namely：内部类和外部类之间完全没有隔阂，数据通信无障碍。

为什么要用内部类：
1. 将内部类向上转型为基类，尤其是转型为一个接口，内部类就有用武之地。因为， 这个内部类是某个接口的实现，能够完全不可见，并且不可用。
   所得到的只是指向基类或接口的引用，所以能够很方便地隐藏实现细节。 namely 完全阻止任何依赖于内部类的编码，并且完全隐藏了实现的细节。
2. 方法内创建内部类
形式： 一个至少有一个方法的接口。
	   在外部类的某个方法类，有一个内部类实现这个接口。这个方法的返回是对这个接口的引用。例子参见p197 第一个例子

==  匿名类
形式： 将返回值的生成与表示这个返回值的类的定义结合在了一起。
public class Outer{
		 new Contents()
		//插入类定义
		{	
			//匿名类中定义字段label,要求传递进来的dest是final类型
			private String label = dest;
		}；
	}
	
}
还可以在匿名类内部进行类似构造器的操作：
	实例初始化
形式
public class Outer{
	public Contents contents{
		return new Contents(final String dest)
		//插入类定义
		{	
			{	//插入{} 为实例初始化
				print("Inside instance initializer");
			}
		}；
	}
	
}
含义： 创建一个继承自Contents的匿名类的对象。

匿名类用于工厂设计模式：
这在语法上提供了更便捷和更优雅的实现，并且也体现了职责单一的面向对象原则。一个类包含了一个职责：制造出应该制造的产品，并能够以一个指定的接口(factory)对外提供服务。
== 嵌套类 static 
形式
