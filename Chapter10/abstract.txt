使用内部类常见的方法是：外部类有一个方法，该方法返回一个指向内部类的引用。
如果想从Outer class 的非静态方法之外的任意位置创建某个内部类的对象。必须OuterClassName.InnerClassName

内部类(非嵌套类)天然的属性很重要：
当生成一个内部类的对象时，此对象与生成它的外部对象之间就有了联系，所以它能访问其外部类的所有成员，而不需要任何特殊条件。
namely：内部类和外部类之间完全没有隔阂，数据通信无障碍。

为什么要用内部类：
1. 将内部类向上转型为基类，尤其是转型为一个接口，内部类就有用武之地。因为， 这个内部类是某个接口的实现，能够完全不可见，并且不可用。
   所得到的只是指向基类或接口的引用，所以能够很方便地隐藏实现细节。 namely 完全阻止任何依赖于内部类的编码，并且完全隐藏了实现的细节。
2. 方法内创建内部类
形式： 一个至少有一个方法的接口。
	   在外部类的某个方法类，有一个内部类实现这个接口。这个方法的返回是对这个接口的引用。例子参见p197 第一个例子
3. 最重要的10.8：内部类最吸引人注意的原因是：每个内部类都能独立的继承自一个接口的实现，所以无论外围类是否已经集成了某个接口的实现，对于内部类没有影响。 
**如果拥有的是抽象类或具体的类，而不是接口，那就只能使用内部类才能实现多重继承。
4. 其他一些特性：
1）内部类可以创建多个实例，每个实例都有自己的状态信息，并且与其外围类对象的信息相互独立。
2）单个外部类中，可以让多个内部类以不同的方式实现同一个接口，或继承同一类。
3）创建内部类对象并不依赖外部类创建-- 嵌套类static
4）内部类没有令人迷惑的is -a 关系，而是组合关系，他就是一个独立的实体。
==  匿名类
形式： 将返回值的生成与表示这个返回值的类的定义结合在了一起。
public class Outer{
	 new Contents()
	//插入类定义
	{	
		//匿名类中定义字段label,要求传递进来的dest是final类型
		private String label = dest;
	}；	
}
还可以在匿名类内部进行类似构造器的操作：
	实例初始化
形式
public class Outer{
	public Contents contents{
		return new Contents(final String dest)
		//插入类定义
		{	
			{	//插入{} 为实例初始化
				print("Inside instance initializer");
			}
		}；
	}
	
}
含义： 创建一个继承自Contents的匿名类的对象。

匿名类用于工厂设计模式：
这在语法上提供了更便捷和更优雅的实现，并且也体现了职责单一的面向对象原则。一个类包含了一个职责：制造出应该制造的产品，并能够以一个指定的接口(factory)对外提供服务。

== 嵌套类 static 
形式
public class Ex19 {
	class Inner1{
		class Inner2{
			void f(){}
		}
		Inner2 makeInner2(){
			return new Inner2();
		}
	}
	Inner1 makeInner1(){
		return new Inner1();
	}
	static class Nested1{
		static class Nested2{
			void f1(){
			}
		}
		void f2(){
		}
	}
}
嵌套类1 要创建嵌套类对象，不需要对依赖其外围类的对象。
2 不能从嵌套类的对象中访问非静态的外部类对象
3 普通类不能有是static字段或者方法。也不能包含嵌套类。 嵌套类可以包含all like this
用处： if 想要创建公共代码，使得他们可以被某个接口的所有不同实现所共用。那么使用接口内部的嵌套类会更方便。

内部类-闭包-回调
回调的价值在于他的灵活性 —— 可以在运行时动态地决定需要调用什么方法。