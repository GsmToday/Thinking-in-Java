"不安全"的编程方式逐渐成为编程代价高昂的原因。初始化和清理正是涉及到安全的两个问题。
初始化
5.1 用构造器确保初始化
先初始化成员变量，再初始化构造器
5.2 重载
区分重载的方法是：每个重载方法都应该有一个独一无二的参数类型列表。参数类型不同 or 参数顺序不同 区分两个方法，以返回值不同来区分重载也是行不通的。
5.3 默认构造器
在不需要使用对象的引用的情况下，可以不用引用指向对象。
如practice 3. 可以直接语句 new E03();
5.4 this keyword
返回当前对象的引用
在构造器中调用重载的另一个构造器：
	page85: 如果为this添加了参数列表，那么就有了不同的含义。这将产生对符合此参数列表的某个构造器的明确调用。
	限制条件： 只能调用一个重载的构造器; 而且这个语句是构造器中的第一句。
5.5 垃圾清理和垃圾回收
什么是垃圾：
	JAVA那些不可达的对象就会变成垃圾，不可达即没有办法再引用该对象了。
gc 垃圾回收期机制（只负责回收new分配的内存，而且时间不确定。）
finalize方法
	gc 本身调用时间就不确定，finalize在gc之前调用，所以finalize调用的时间就更不确定了，所以sun不推荐用finalize。
JAVA的清理机制：
	自适应的gc, 停止-复制，标记-清理。
5.6 成员初始化
5.7 构造器初始化
先初始化成员变量，再初始化构造器
静态数据的初始化：
static： 静态数据都只占用一份存储区域。只会初始化一次，再有初始化语句就直接跳过了。
static块，如果执行，块内都执行。
5.8 数组初始化
当数组元素不确定时候，用new来进行初始化。
数组初始化有动态初始化和静态初始化两种方式。
5.8.1 可变参数列表 
指定元素列表后，编译器会自动填充为数组 或者直接传递数组。
5.9 Enum枚举类型 
定义常量的高效方式